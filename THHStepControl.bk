/*
  Serial Event example


*/


#include "DefSystem.h"
#include "StringSplitter.h"
StringSplitter *splitter;
String inputString = "";         // a String to hold incoming data
bool stringComplete = false;  // whether the string is complete

int mode_process = eMain_Do_nothing;
int old_mode_process = eMain_Do_nothing;

int motor_direction = CW;

double motor_num_pulse = 1;
double motor_num_degree = 1;
double motor_num_revolution = 1;

double motor_rpm = 1;

double motor_microstep = 2;
const double motor_step = 1.8;
double pulse_delay = 1000;


void setup() {
  // initialize serial:
  Serial.begin(9600);
  // reserve 200 bytes for the inputString:
  //inputString.reserve(200);

  //Init output
  InitOutput();
}

void loop() {
  processCommand();
  processMotor();
}


void processMotor()
{
  switch (mode_process)
  {
    case eMain_Do_nothing:
      break;

    case eMain_Change_direction:
      changeMotorDirection(motor_direction);
      break;

    case eMain_Run_pulse:
      runByPulse(motor_num_pulse);
      mode_process = eMain_Do_nothing;
      break;

    case eMain_Run_degree:
      runByDegree(motor_num_degree);
      mode_process = eMain_Do_nothing;
      break;

    case eMain_Run_revolution:
      runByRevolution(motor_num_revolution);
      mode_process = eMain_Do_nothing;
      break;


    case eMain_Change_speed:
      changeSpeed(motor_rpm);
      mode_process = eMain_Do_nothing;
      break;

    case eMain_Change_speed_adc:
      break;

    case eMain_Change_resolution:
      changeMicrostep();
      runByRevolution(1);
      mode_process = eMain_Do_nothing;
      break;

  }
}

void changeMicrostep()
{
  double _step = motor_step / motor_microstep;
  double freq = (360 * motor_rpm) / (60 * _step);
  pulse_delay = 1000000 / freq; //us

#ifdef DEBUG
  Serial.println("Changed Microstep -> motor_step = " + String(motor_step));
  Serial.println("Changed Microstep -> _step = " + String(_step));
  Serial.println("Changed Microstep -> freq = " + String(freq));
  Serial.println("Changed Microstep -> pulse_delay = " + String(pulse_delay));
#endif
}

void changeSpeed(double rpm)
{
  double _step = motor_step / motor_microstep;
  double freq = (360 * rpm) / (60 * _step);
  pulse_delay = 1 / freq * 1000000; //us

#ifdef DEBUG
  Serial.println("Changed Microstep -> motor_step = " + String(motor_step));
  Serial.println("Changed speed -> _step = " + String(_step));
  Serial.println("Changed speed -> freq = " + String(freq));
  Serial.println("Changed speed -> pulse_delay = " + String(pulse_delay));
#endif
}

void runByPulse(int nPulse)
{
  enableMotor(true);
  changeMotorDirection(motor_direction);
  for (int i = 0; i < nPulse; i++)
  {
    pulseMotor(pulse_delay);
  }
  enableMotor(false);


#ifdef DEBUG
  Serial.println("Ran " + String(nPulse) + " pulse");
#endif
}


void runByDegree(double nDegree)
{
  enableMotor(true);
  changeMotorDirection(motor_direction);

  //convert degree to pulse
  double _step = motor_step / motor_microstep;
  double nPulse = nDegree / _step;

  for (int i = 0; i < nPulse; i++)
  {
    pulseMotor(pulse_delay);
  }
  enableMotor(false);


#ifdef DEBUG
  Serial.println("runByDegree -> _step = " + String(_step));
  Serial.println("runByDegree -> motor_step = " + String(motor_step));
  Serial.println("runByDegree -> nPulse = " + String(nPulse));
  Serial.println("runByDegree -> pulse_delay = " + String(pulse_delay));
  Serial.println("runByDegree " + String(nDegree) + " degree");
#endif
}


void runByRevolution(int nRev)
{

  enableMotor(true);
  changeMotorDirection(motor_direction);

  //convert degree to pulse
  double _step = motor_step / motor_microstep;
  double nPulse = 360 / _step * nRev;
#ifdef DEBUG
  Serial.println("runByRevolution -> _step = " + String(_step));
  Serial.println("Changed Microstep -> motor_step = " + String(motor_step));
  Serial.println("runByRevolution -> nPulse = " + String(nPulse));
  Serial.println("runByRevolution -> pulse_delay " + String(pulse_delay) + " pulse");
#endif
  if (nRev > 0) //quay n vong
  {
    for (int i = 0; i < nPulse; i++)
    {
      pulseMotor(pulse_delay);
      if (mode_process != eMain_Run_revolution)
        break;
    }
  }
  else if (nRev < 0) //quay lien tuc
  {
    while (mode_process == eMain_Run_revolution)
    {
      pulseMotor(pulse_delay);
    }
  }
  else // = 0 -> stop
  {
    enableMotor(false);
  }


#ifdef DEBUG
  Serial.println("Ran " + String(nRev) + " rev");
#endif
}

void pulseMotor(int time_delay)
{
  digitalWrite(PIN_PULSE, HIGH);
  delayMicroseconds(time_delay);
  digitalWrite(PIN_PULSE, LOW);
}


void InitOutput()
{
  //Output
  pinMode(PIN_PULSE, OUTPUT);
  pinMode(PIN_DIRECTION, OUTPUT);
  pinMode(PIN_ENABLE, OUTPUT);

  digitalWrite(PIN_ENABLE, LOW);
  digitalWrite(PIN_PULSE, LOW);
  digitalWrite(PIN_DIRECTION, LOW);

}
void enableMotor(bool en)
{
  if (en)
  {
    digitalWrite(PIN_ENABLE, HIGH);
  }
  else
  {
    digitalWrite(PIN_ENABLE, LOW);
  }
  delayMicroseconds(10);
}


void changeMotorDirection(int dir)
{
  enableMotor(true);
  switch (dir)
  {
    case CW:
      digitalWrite(PIN_DIRECTION, HIGH);
      break;

    case CCW:
      digitalWrite(PIN_DIRECTION, LOW);
      break;
    default:
#ifdef DEBUG
      Serial.println("Not support dir = " + String(dir));
#endif
      break;
  }
  delayMicroseconds(10);
}


void processCommand()
{
  // print the string when a newline arrives:
  if (!stringComplete)
    return;


#ifdef DEBUG
  Serial.println(inputString);
#endif

  // mode_param1_param2_..._paramn\n
  // split data
  splitter = new StringSplitter(inputString, '_', 3);  // new StringSplitter(string_to_split, delimiter, limit)
  int itemCount = splitter->getItemCount();
  if (itemCount == 0)
  {
    clear_buffer();
    return;
  }

#ifdef DEBUG
  Serial.println("Item count: " + String(itemCount));
  for (int i = 0; i < itemCount; i++) {
    String item = splitter->getItemAtIndex(i);
    Serial.println("Item @ index " + String(i) + ": " + String(item));
  }
#endif

  //consider mode by 1st param
  String cmd_item = splitter->getItemAtIndex(0);

  //chieu quay
  if (cmd_item.equalsIgnoreCase(ROTATION))
  {
    mode_process = eMain_Change_direction;
    int dir = splitter->getItemAtIndex(1).toInt();
    motor_direction = dir;
#ifdef DEBUG
    Serial.println("motor_direction = CCW -> " +  String(motor_direction));
#endif

  }
  //che do quay
  else if (cmd_item.equalsIgnoreCase(RUN))
  {
    //quay n xung
    if (splitter->getItemAtIndex(1).equalsIgnoreCase(RUN_PULSE))
    {
      mode_process = eMain_Run_pulse;
      motor_num_pulse = splitter->getItemAtIndex(2).toDouble();
#ifdef DEBUG
      Serial.println("eMain_Run_pulse = " + String(motor_num_pulse));
#endif
    }

    //quay n do
    else if (splitter->getItemAtIndex(1).equalsIgnoreCase(RUN_DEGREE))
    {
      mode_process = eMain_Run_degree;
      motor_num_degree = splitter->getItemAtIndex(2).toDouble();
#ifdef DEBUG
      Serial.println("eMain_Run_degree = " + String(motor_num_degree));
#endif
    }

    //quay n vong
    if (splitter->getItemAtIndex(1).equalsIgnoreCase(RUN_REVOLUTION))
    {
      mode_process = eMain_Run_revolution;
      motor_num_revolution = splitter->getItemAtIndex(2).toDouble();
#ifdef DEBUG
      Serial.println("eMain_Run_revolution = " + String(motor_num_revolution));
#endif
    }
  }

  //toc do quay
  else if (cmd_item.equalsIgnoreCase(SPEED))
  {
    mode_process = eMain_Change_speed;
    motor_rpm = splitter->getItemAtIndex(1).toDouble();
#ifdef DEBUG
    Serial.println("eMain_Change_speed = " + String(motor_rpm));
#endif
  }

  //toc do quay theo adc
  else if (cmd_item.equalsIgnoreCase(SPEED_ADC))
  {
    mode_process = eMain_Change_speed_adc;
    motor_rpm = splitter->getItemAtIndex(1).toDouble();
#ifdef DEBUG
    Serial.println("eMain_Change_speed_adc = " + String(motor_rpm));
#endif
  }

  //thay doi do phan giai
  else if (cmd_item.equalsIgnoreCase(RESOLUTION))
  {
    mode_process = eMain_Change_resolution;
    motor_microstep = splitter->getItemAtIndex(1).toDouble();
#ifdef DEBUG
    Serial.println("eMain_Change_resolution = " + String(motor_microstep) + " - microstep");
#endif
  }

  clear_buffer();

}

void clear_buffer()
{

  // clear the string:
  inputString = "";
  stringComplete = false;
  delete splitter;
  splitter = NULL;

}
/*
  SerialEvent occurs whenever a new data comes in the hardware serial RX. This
  routine is run between each time loop() runs, so using delay inside loop can
  delay response. Multiple bytes of data may be available.
*/
void serialEvent() {
  while (Serial.available()) {
    //
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag so the main loop can
    // do something about it:
    if (inChar == '\n') {
      stringComplete = true;
      mode_process = eMain_Do_nothing;
    }
  }
}
